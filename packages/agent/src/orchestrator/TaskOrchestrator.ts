// =============================================================================
// ORBIT AI AGENT - TASK ORCHESTRATOR
// =============================================================================

import { 
  Action, 
  TaskResult, 
  TaskPriority, 
  TaskStatus,
  AgentContext 
} from '../types/index.js';
import { OrbitAgent } from '../core/OrbitAgent.js';
import { Logger } from '../utils/Logger.js';

/**
 * üé≠ ORQUESTADOR DE TAREAS
 * 
 * El "director de orquesta" que coordina y ejecuta todas las tareas del agente:
 * - ‚ö° Cola de prioridades inteligente
 * - üîÑ Ejecuci√≥n concurrente optimizada
 * - üìä Monitoreo de recursos
 * - üõ°Ô∏è Manejo robusto de errores
 * - ‚è∞ Sistema de triggers autom√°ticos
 */
export class TaskOrchestrator {
  private readonly agent: OrbitAgent;
  private readonly logger: Logger;
  
  // Cola de tareas con prioridades
  private taskQueue: PriorityQueue<TaskItem>;
  private runningTasks: Map<string, TaskExecution> = new Map();
  private completedTasks: Map<string, TaskResult> = new Map();
  
  // Configuraci√≥n del orquestador
  private readonly config = {
    maxConcurrentTasks: 10,
    maxTaskDuration: 5 * 60 * 1000, // 5 minutos
    retryAttempts: 3,
    retryDelay: 1000, // base delay for exponential backoff
    healthCheckInterval: 30000 // 30 segundos
  };
  
  // Estado del orquestrador
  private isRunning: boolean = false;
  private resourceMonitor: ResourceMonitor;
  private triggers: TriggerSystem;
  
  constructor(agent: OrbitAgent) {
    this.agent = agent;
    this.logger = new Logger('TaskOrchestrator');
    this.taskQueue = new PriorityQueue<TaskItem>();
    this.resourceMonitor = new ResourceMonitor();
    this.triggers = new TriggerSystem(this);
  }
  
  // ==========================================================================
  // LIFECYCLE MANAGEMENT
  // ==========================================================================
  
  async start(): Promise<void> {
    if (this.isRunning) {
      this.logger.warn('Task orchestrator already running');
      return;
    }
    
    this.logger.info('üöÄ Starting task orchestrator...');
    
    try {
      // Inicializar sistemas
      await this.resourceMonitor.initialize();
      await this.triggers.initialize();
      
      // Iniciar bucle principal de ejecuci√≥n
      this.startExecutionLoop();
      
      // Iniciar monitoreo de salud
      this.startHealthMonitoring();
      
      this.isRunning = true;
      this.logger.info('‚úÖ Task orchestrator started successfully');
      
    } catch (error) {
      this.logger.error('‚ùå Failed to start task orchestrator:', error);
      throw error;
    }
  }
  
  async stop(): Promise<void> {
    if (!this.isRunning) return;
    
    this.logger.info('üõë Stopping task orchestrator...');
    
    // Marcar como no running para detener nuevas ejecuciones
    this.isRunning = false;
    
    // Esperar que terminen las tareas cr√≠ticas
    await this.gracefulShutdown();
    
    // Detener sistemas
    await this.triggers.stop();
    await this.resourceMonitor.stop();
    
    this.logger.info('‚úÖ Task orchestrator stopped');
  }
  
  // ==========================================================================
  // GESTI√ìN DE TAREAS
  // ==========================================================================
  
  /**
   * Encola una nueva tarea para ejecuci√≥n
   */
  async enqueueTask(action: Action, context: AgentContext, options: EnqueueOptions = {}): Promise<string> {
    const taskId = `task_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;\n    \n    const taskItem: TaskItem = {\n      id: taskId,\n      action,\n      context,\n      enqueuedAt: new Date(),\n      priority: this.calculateTaskPriority(action, options),\n      retryCount: 0,\n      maxRetries: options.maxRetries || this.config.retryAttempts,\n      timeout: options.timeout || this.config.maxTaskDuration,\n      dependencies: action.dependencies || [],\n      metadata: {\n        source: options.source || 'manual',\n        urgent: options.urgent || false,\n        businessId: context.businessId\n      }\n    };\n    \n    // Validar dependencias\n    if (taskItem.dependencies.length > 0) {\n      const missingDeps = await this.checkDependencies(taskItem.dependencies);\n      if (missingDeps.length > 0) {\n        throw new Error(`Missing dependencies: ${missingDeps.join(', ')}`);\n      }\n    }\n    \n    // Encolar con prioridad\n    this.taskQueue.enqueue(taskItem, taskItem.priority);\n    \n    this.logger.info(`üìã Task enqueued: ${taskId} (${action.type}) [Priority: ${taskItem.priority}]`);\n    \n    return taskId;\n  }\n  \n  /**\n   * Obtiene el estado de una tarea\n   */\n  getTaskStatus(taskId: string): TaskStatus | undefined {\n    // Verificar en tareas en ejecuci√≥n\n    const runningTask = this.runningTasks.get(taskId);\n    if (runningTask) {\n      return 'in_progress';\n    }\n    \n    // Verificar en tareas completadas\n    const completedTask = this.completedTasks.get(taskId);\n    if (completedTask) {\n      return completedTask.status;\n    }\n    \n    // Verificar en cola\n    if (this.taskQueue.contains(taskId)) {\n      return 'pending';\n    }\n    \n    return undefined;\n  }\n  \n  /**\n   * Cancela una tarea\n   */\n  async cancelTask(taskId: string, reason: string = 'Cancelled by user'): Promise<boolean> {\n    // Intentar cancelar desde la cola\n    if (this.taskQueue.remove(taskId)) {\n      this.logger.info(`‚ùå Task cancelled from queue: ${taskId}`);\n      return true;\n    }\n    \n    // Intentar cancelar tarea en ejecuci√≥n\n    const runningTask = this.runningTasks.get(taskId);\n    if (runningTask) {\n      runningTask.cancelled = true;\n      runningTask.cancellationReason = reason;\n      \n      this.logger.info(`‚ùå Task marked for cancellation: ${taskId}`);\n      return true;\n    }\n    \n    return false;\n  }\n  \n  // ==========================================================================\n  // BUCLE PRINCIPAL DE EJECUCI√ìN\n  // ==========================================================================\n  \n  private startExecutionLoop(): void {\n    const executeNext = async () => {\n      if (!this.isRunning) return;\n      \n      try {\n        // Verificar si podemos ejecutar m√°s tareas\n        if (this.canExecuteMoreTasks()) {\n          const nextTask = this.taskQueue.dequeue();\n          \n          if (nextTask) {\n            // Ejecutar tarea de forma as√≠ncrona\n            this.executeTask(nextTask).catch(error => {\n              this.logger.error(`‚ùå Task execution failed: ${nextTask.id}`, error);\n            });\n          }\n        }\n        \n        // Programar siguiente iteraci√≥n\n        setTimeout(executeNext, 100); // Check every 100ms\n        \n      } catch (error) {\n        this.logger.error('‚ùå Execution loop error:', error);\n        setTimeout(executeNext, 1000); // Wait longer on error\n      }\n    };\n    \n    executeNext();\n  }\n  \n  private async executeTask(taskItem: TaskItem): Promise<void> {\n    const { id, action, context } = taskItem;\n    \n    this.logger.info(`‚ö° Executing task: ${id} (${action.type})`);\n    \n    // Crear ejecuci√≥n de tarea\n    const execution: TaskExecution = {\n      taskId: id,\n      startedAt: new Date(),\n      cancelled: false,\n      timeout: setTimeout(() => this.handleTaskTimeout(id), taskItem.timeout)\n    };\n    \n    this.runningTasks.set(id, execution);\n    \n    try {\n      // Verificar recursos antes de ejecutar\n      const hasResources = await this.resourceMonitor.checkResources(action);\n      if (!hasResources) {\n        throw new Error('Insufficient resources to execute task');\n      }\n      \n      // Ejecutar la acci√≥n usando el motor de ejecuci√≥n del agente\n      const result = await this.agent['executor'].execute(action, context);\n      \n      // Verificar si fue cancelada durante la ejecuci√≥n\n      if (execution.cancelled) {\n        this.completeTask(id, {\n          taskId: id,\n          status: 'cancelled',\n          error: execution.cancellationReason || 'Task was cancelled',\n          duration: Date.now() - execution.startedAt.getTime(),\n          timestamp: new Date()\n        });\n        return;\n      }\n      \n      // Marcar como completada exitosamente\n      this.completeTask(id, result);\n      \n      this.logger.info(`‚úÖ Task completed successfully: ${id}`);\n      \n    } catch (error) {\n      this.logger.error(`‚ùå Task execution failed: ${id}`, error);\n      \n      // Manejar reintento si es apropiado\n      const shouldRetry = await this.shouldRetryTask(taskItem, error);\n      \n      if (shouldRetry) {\n        await this.scheduleRetry(taskItem, error);\n      } else {\n        // Marcar como fallida\n        this.completeTask(id, {\n          taskId: id,\n          status: 'failed',\n          error: error.message,\n          duration: Date.now() - execution.startedAt.getTime(),\n          timestamp: new Date()\n        });\n      }\n      \n    } finally {\n      // Limpiar timeout y ejecuci√≥n\n      clearTimeout(execution.timeout);\n      this.runningTasks.delete(id);\n    }\n  }\n  \n  // ==========================================================================\n  // GESTI√ìN DE PRIORIDADES Y RECURSOS\n  // ==========================================================================\n  \n  private calculateTaskPriority(action: Action, options: EnqueueOptions): number {\n    let priority = this.getBasePriority(action.priority);\n    \n    // Ajustes por urgencia\n    if (options.urgent) {\n      priority += 500;\n    }\n    \n    // Ajustes por tipo de tarea\n    const typeBonus = this.getTypePriorityBonus(action.type);\n    priority += typeBonus;\n    \n    // Ajustes por deadline\n    if (action.deadline) {\n      const timeUntilDeadline = action.deadline.getTime() - Date.now();\n      if (timeUntilDeadline < 60 * 60 * 1000) { // Menos de 1 hora\n        priority += 200;\n      } else if (timeUntilDeadline < 24 * 60 * 60 * 1000) { // Menos de 24 horas\n        priority += 100;\n      }\n    }\n    \n    return priority;\n  }\n  \n  private getBasePriority(priority: TaskPriority): number {\n    const priorities = {\n      critical: 1000,\n      high: 500,\n      medium: 100,\n      low: 50,\n      background: 10\n    };\n    \n    return priorities[priority] || 100;\n  }\n  \n  private getTypePriorityBonus(actionType: string): number {\n    // Bonus por tipo de acci√≥n\n    const typeBonus: Record<string, number> = {\n      send_message: 200,      // Respuestas a clientes son prioritarias\n      create_promotion: 150,   // Promociones son importantes\n      analyze_competitor: 50,  // An√°lisis puede esperar\n      generate_report: 25,     // Reportes tienen baja prioridad\n      update_pricing: 100,     // Cambios de precio son moderadamente importantes\n    };\n    \n    return typeBonus[actionType] || 0;\n  }\n  \n  private canExecuteMoreTasks(): boolean {\n    // Verificar l√≠mites de concurrencia\n    if (this.runningTasks.size >= this.config.maxConcurrentTasks) {\n      return false;\n    }\n    \n    // Verificar recursos del sistema\n    if (!this.resourceMonitor.hasAvailableResources()) {\n      return false;\n    }\n    \n    return true;\n  }\n  \n  // ==========================================================================\n  // MANEJO DE ERRORES Y REINTENTOS\n  // ==========================================================================\n  \n  private async shouldRetryTask(taskItem: TaskItem, error: Error): Promise<boolean> {\n    // No reintentar si ya alcanz√≥ el m√°ximo\n    if (taskItem.retryCount >= taskItem.maxRetries) {\n      return false;\n    }\n    \n    // No reintentar errores de validaci√≥n\n    if (error.message.includes('validation') || error.message.includes('invalid')) {\n      return false;\n    }\n    \n    // No reintentar tareas cr√≠ticas con errores de negocio\n    if (taskItem.action.priority === 'critical' && error.message.includes('business')) {\n      return false;\n    }\n    \n    // Reintentar errores de red/temporales\n    if (error.message.includes('network') || \n        error.message.includes('timeout') || \n        error.message.includes('rate limit')) {\n      return true;\n    }\n    \n    return taskItem.retryCount < taskItem.maxRetries;\n  }\n  \n  private async scheduleRetry(taskItem: TaskItem, error: Error): Promise<void> {\n    taskItem.retryCount += 1;\n    \n    // Calcular delay con backoff exponencial\n    const delay = this.config.retryDelay * Math.pow(2, taskItem.retryCount - 1);\n    \n    this.logger.info(\n      `üîÑ Scheduling retry ${taskItem.retryCount}/${taskItem.maxRetries} for task ${taskItem.id} in ${delay}ms`\n    );\n    \n    // Programar reintento\n    setTimeout(() => {\n      if (this.isRunning) {\n        this.taskQueue.enqueue(taskItem, taskItem.priority - 10); // Slightly lower priority for retries\n      }\n    }, delay);\n  }\n  \n  private handleTaskTimeout(taskId: string): void {\n    const execution = this.runningTasks.get(taskId);\n    if (execution && !execution.cancelled) {\n      this.logger.warn(`‚è∞ Task timeout: ${taskId}`);\n      \n      execution.cancelled = true;\n      execution.cancellationReason = 'Task timeout';\n    }\n  }\n  \n  // ==========================================================================\n  // MONITOREO Y SALUD\n  // ==========================================================================\n  \n  private startHealthMonitoring(): void {\n    const healthCheck = () => {\n      if (!this.isRunning) return;\n      \n      try {\n        this.performHealthCheck();\n        setTimeout(healthCheck, this.config.healthCheckInterval);\n      } catch (error) {\n        this.logger.error('‚ùå Health check failed:', error);\n        setTimeout(healthCheck, this.config.healthCheckInterval * 2);\n      }\n    };\n    \n    healthCheck();\n  }\n  \n  private performHealthCheck(): void {\n    const stats = this.getOrchestratorStats();\n    \n    // Log estad√≠sticas cada cierto tiempo\n    if (Date.now() % (5 * 60 * 1000) < this.config.healthCheckInterval) { // Every 5 minutes\n      this.logger.info('üìä Orchestrator stats:', stats);\n    }\n    \n    // Detectar problemas\n    if (stats.runningTasks > this.config.maxConcurrentTasks * 0.9) {\n      this.logger.warn('‚ö†Ô∏è High task load detected');\n    }\n    \n    if (stats.queueSize > 100) {\n      this.logger.warn('‚ö†Ô∏è Large queue size detected');\n    }\n    \n    if (stats.failureRate > 0.1) { // More than 10% failures\n      this.logger.warn('‚ö†Ô∏è High failure rate detected');\n    }\n  }\n  \n  public getOrchestratorStats(): OrchestratorStats {\n    const completedTasksArray = Array.from(this.completedTasks.values());\n    const recentTasks = completedTasksArray.filter(\n      task => Date.now() - task.timestamp.getTime() < 60 * 60 * 1000 // Last hour\n    );\n    \n    const failedTasks = recentTasks.filter(task => task.status === 'failed');\n    \n    return {\n      queueSize: this.taskQueue.size(),\n      runningTasks: this.runningTasks.size,\n      completedTasks: this.completedTasks.size,\n      recentTasks: recentTasks.length,\n      failureRate: recentTasks.length > 0 ? failedTasks.length / recentTasks.length : 0,\n      avgExecutionTime: recentTasks.length > 0 \n        ? recentTasks.reduce((sum, task) => sum + (task.duration || 0), 0) / recentTasks.length \n        : 0,\n      resourceUtilization: this.resourceMonitor.getUtilization()\n    };\n  }\n  \n  // ==========================================================================\n  // TRIGGERS AUTOM√ÅTICOS\n  // ==========================================================================\n  \n  public registerTrigger(trigger: AutoTrigger): void {\n    this.triggers.register(trigger);\n  }\n  \n  public unregisterTrigger(triggerId: string): void {\n    this.triggers.unregister(triggerId);\n  }\n  \n  // ==========================================================================\n  // UTILIDADES PRIVADAS\n  // ==========================================================================\n  \n  private completeTask(taskId: string, result: TaskResult): void {\n    this.completedTasks.set(taskId, result);\n    \n    // Limpiar tareas completadas muy antiguas\n    if (this.completedTasks.size > 10000) {\n      this.cleanupOldTasks();\n    }\n    \n    // Emitir evento de finalizaci√≥n\n    this.agent.emit('task.completed', { taskId, result });\n  }\n  \n  private cleanupOldTasks(): void {\n    const cutoffTime = Date.now() - 24 * 60 * 60 * 1000; // 24 horas\n    \n    for (const [taskId, result] of this.completedTasks.entries()) {\n      if (result.timestamp.getTime() < cutoffTime) {\n        this.completedTasks.delete(taskId);\n      }\n    }\n  }\n  \n  private async checkDependencies(dependencies: string[]): Promise<string[]> {\n    const missingDeps = [];\n    \n    for (const dep of dependencies) {\n      const depStatus = this.getTaskStatus(dep);\n      if (depStatus !== 'completed') {\n        missingDeps.push(dep);\n      }\n    }\n    \n    return missingDeps;\n  }\n  \n  private async gracefulShutdown(): Promise<void> {\n    const maxWaitTime = 30000; // 30 seconds\n    const startTime = Date.now();\n    \n    while (this.runningTasks.size > 0 && (Date.now() - startTime) < maxWaitTime) {\n      this.logger.info(`‚è≥ Waiting for ${this.runningTasks.size} tasks to complete...`);\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    // Cancelar tareas restantes\n    for (const [taskId] of this.runningTasks) {\n      await this.cancelTask(taskId, 'System shutdown');\n    }\n  }\n}\n\n// =============================================================================\n// SUPPORTING CLASSES\n// =============================================================================\n\n/**\n * Cola de prioridades optimizada para tareas\n */\nclass PriorityQueue<T extends { id: string }> {\n  private items: Array<{ item: T; priority: number }> = [];\n  \n  enqueue(item: T, priority: number): void {\n    const queueItem = { item, priority };\n    \n    // Insertar en posici√≥n correcta seg√∫n prioridad\n    let inserted = false;\n    for (let i = 0; i < this.items.length; i++) {\n      if (priority > this.items[i].priority) {\n        this.items.splice(i, 0, queueItem);\n        inserted = true;\n        break;\n      }\n    }\n    \n    if (!inserted) {\n      this.items.push(queueItem);\n    }\n  }\n  \n  dequeue(): T | undefined {\n    const item = this.items.shift();\n    return item?.item;\n  }\n  \n  contains(id: string): boolean {\n    return this.items.some(item => item.item.id === id);\n  }\n  \n  remove(id: string): boolean {\n    const index = this.items.findIndex(item => item.item.id === id);\n    if (index >= 0) {\n      this.items.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n  \n  size(): number {\n    return this.items.length;\n  }\n}\n\n/**\n * Monitor de recursos del sistema\n */\nclass ResourceMonitor {\n  private logger: Logger;\n  private utilization: ResourceUtilization = {\n    cpu: 0,\n    memory: 0,\n    tokens: 0,\n    apiCalls: 0\n  };\n  \n  constructor() {\n    this.logger = new Logger('ResourceMonitor');\n  }\n  \n  async initialize(): Promise<void> {\n    this.logger.info('üìä Resource monitor initialized');\n    this.startMonitoring();\n  }\n  \n  async stop(): Promise<void> {\n    this.logger.info('üõë Resource monitor stopped');\n  }\n  \n  async checkResources(action: Action): Promise<boolean> {\n    // Verificar si hay recursos suficientes para ejecutar la acci√≥n\n    const estimated = this.estimateResourceUsage(action);\n    \n    return (\n      this.utilization.cpu + estimated.cpu < 90 &&\n      this.utilization.memory + estimated.memory < 90 &&\n      this.utilization.tokens + estimated.tokens < 1000000 &&\n      this.utilization.apiCalls + estimated.apiCalls < 1000\n    );\n  }\n  \n  hasAvailableResources(): boolean {\n    return (\n      this.utilization.cpu < 85 &&\n      this.utilization.memory < 85 &&\n      this.utilization.tokens < 900000 &&\n      this.utilization.apiCalls < 900\n    );\n  }\n  \n  getUtilization(): ResourceUtilization {\n    return { ...this.utilization };\n  }\n  \n  private startMonitoring(): void {\n    setInterval(() => {\n      this.updateUtilization();\n    }, 10000); // Update every 10 seconds\n  }\n  \n  private updateUtilization(): void {\n    // En producci√≥n, obtener m√©tricas reales del sistema\n    this.utilization = {\n      cpu: Math.random() * 50, // Simulated\n      memory: Math.random() * 60, // Simulated  \n      tokens: Math.floor(Math.random() * 100000),\n      apiCalls: Math.floor(Math.random() * 100)\n    };\n  }\n  \n  private estimateResourceUsage(action: Action): ResourceUtilization {\n    // Estimaci√≥n simple basada en el tipo de acci√≥n\n    const estimates: Record<string, ResourceUtilization> = {\n      send_message: { cpu: 5, memory: 10, tokens: 100, apiCalls: 1 },\n      create_content: { cpu: 15, memory: 20, tokens: 1000, apiCalls: 3 },\n      analyze_competitor: { cpu: 25, memory: 30, tokens: 2000, apiCalls: 5 },\n      generate_report: { cpu: 30, memory: 40, tokens: 3000, apiCalls: 10 }\n    };\n    \n    return estimates[action.type] || { cpu: 10, memory: 15, tokens: 500, apiCalls: 2 };\n  }\n}\n\n/**\n * Sistema de triggers autom√°ticos\n */\nclass TriggerSystem {\n  private orchestrator: TaskOrchestrator;\n  private logger: Logger;\n  private triggers: Map<string, AutoTrigger> = new Map();\n  private isRunning: boolean = false;\n  \n  constructor(orchestrator: TaskOrchestrator) {\n    this.orchestrator = orchestrator;\n    this.logger = new Logger('TriggerSystem');\n  }\n  \n  async initialize(): Promise<void> {\n    this.isRunning = true;\n    this.startTriggerLoop();\n    this.logger.info('üéØ Trigger system initialized');\n  }\n  \n  async stop(): Promise<void> {\n    this.isRunning = false;\n    this.logger.info('üõë Trigger system stopped');\n  }\n  \n  register(trigger: AutoTrigger): void {\n    this.triggers.set(trigger.id, trigger);\n    this.logger.info(`üéØ Trigger registered: ${trigger.id}`);\n  }\n  \n  unregister(triggerId: string): void {\n    this.triggers.delete(triggerId);\n    this.logger.info(`üóëÔ∏è Trigger unregistered: ${triggerId}`);\n  }\n  \n  private startTriggerLoop(): void {\n    const checkTriggers = async () => {\n      if (!this.isRunning) return;\n      \n      try {\n        for (const [id, trigger] of this.triggers) {\n          const shouldTrigger = await this.evaluateTrigger(trigger);\n          \n          if (shouldTrigger) {\n            await this.executeTrigger(trigger);\n          }\n        }\n        \n        setTimeout(checkTriggers, 5000); // Check every 5 seconds\n        \n      } catch (error) {\n        this.logger.error('‚ùå Trigger evaluation failed:', error);\n        setTimeout(checkTriggers, 10000);\n      }\n    };\n    \n    checkTriggers();\n  }\n  \n  private async evaluateTrigger(trigger: AutoTrigger): Promise<boolean> {\n    // Evaluar condiciones del trigger\n    try {\n      return await trigger.condition();\n    } catch (error) {\n      this.logger.error(`‚ùå Trigger evaluation failed for ${trigger.id}:`, error);\n      return false;\n    }\n  }\n  \n  private async executeTrigger(trigger: AutoTrigger): Promise<void> {\n    try {\n      this.logger.info(`üöÄ Executing trigger: ${trigger.id}`);\n      \n      const actions = await trigger.actions();\n      \n      for (const action of actions) {\n        await this.orchestrator.enqueueTask(action, trigger.context, {\n          source: 'trigger',\n          urgent: trigger.urgent || false\n        });\n      }\n      \n      // Actualizar √∫ltima ejecuci√≥n\n      trigger.lastExecuted = new Date();\n      \n    } catch (error) {\n      this.logger.error(`‚ùå Trigger execution failed for ${trigger.id}:`, error);\n    }\n  }\n}\n\n// =============================================================================\n// INTERFACES Y TIPOS\n// =============================================================================\n\ninterface TaskItem {\n  id: string;\n  action: Action;\n  context: AgentContext;\n  enqueuedAt: Date;\n  priority: number;\n  retryCount: number;\n  maxRetries: number;\n  timeout: number;\n  dependencies: string[];\n  metadata: {\n    source: string;\n    urgent: boolean;\n    businessId: string;\n  };\n}\n\ninterface TaskExecution {\n  taskId: string;\n  startedAt: Date;\n  cancelled: boolean;\n  cancellationReason?: string;\n  timeout: NodeJS.Timeout;\n}\n\ninterface EnqueueOptions {\n  urgent?: boolean;\n  maxRetries?: number;\n  timeout?: number;\n  source?: string;\n}\n\ninterface OrchestratorStats {\n  queueSize: number;\n  runningTasks: number;\n  completedTasks: number;\n  recentTasks: number;\n  failureRate: number;\n  avgExecutionTime: number;\n  resourceUtilization: ResourceUtilization;\n}\n\ninterface ResourceUtilization {\n  cpu: number;    // Percentage\n  memory: number; // Percentage  \n  tokens: number; // Count\n  apiCalls: number; // Count\n}\n\ninterface AutoTrigger {\n  id: string;\n  name: string;\n  condition: () => Promise<boolean>;\n  actions: () => Promise<Action[]>;\n  context: AgentContext;\n  urgent?: boolean;\n  lastExecuted?: Date;\n}"