// =============================================================================
// ORBIT AI AGENT - MOTOR DE PLANIFICACI√ìN
// =============================================================================

import { 
  BusinessAnalysis, 
  Action, 
  Opportunity, 
  Risk,
  BusinessProfile,
  AgentContext
} from '../types/index.js';
import { MemoryManager } from '../core/MemoryManager.js';
import { AgentToolkit } from '../tools/AgentToolkit.js';
import { Logger } from '../utils/Logger.js';

/**
 * üéØ MOTOR DE PLANIFICACI√ìN ESTRAT√âGICA
 * 
 * Transforma insights del an√°lisis en planes de acci√≥n concretos:
 * - üìã Planificaci√≥n multi-horizonte (inmediato, corto, mediano plazo)
 * - üéØ Priorizaci√≥n inteligente de acciones
 * - üîó Coordinaci√≥n de acciones interdependientes
 * - ‚öñÔ∏è Balance entre recursos y impacto
 * - üß† Aprendizaje de efectividad de planes anteriores
 */
export class PlanningEngine {
  private readonly memory: MemoryManager;
  private readonly tools: AgentToolkit;
  private readonly logger: Logger;
  
  // Cache de planes para optimizaci√≥n
  private planCache = new Map<string, { plan: ActionPlan; timestamp: Date }>();
  private readonly cacheTimeout = 10 * 60 * 1000; // 10 minutos
  
  // Estrategias de planificaci√≥n por industria
  private industryStrategies = new Map<string, PlanningStrategy>();
  
  constructor(memory: MemoryManager, tools: AgentToolkit) {\n    this.memory = memory;\n    this.tools = tools;\n    this.logger = new Logger('PlanningEngine');\n    \n    this.initializeIndustryStrategies();\n  }\n  \n  // ==========================================================================\n  // PLANIFICACI√ìN PRINCIPAL\n  // ==========================================================================\n  \n  /**\n   * Crea un plan de acci√≥n completo basado en el an√°lisis del negocio\n   */\n  async createActionPlan(\n    analysis: BusinessAnalysis, \n    options: PlanningOptions = {}\n  ): Promise<ActionPlan> {\n    const { \n      businessId, \n      timeHorizon = 'immediate', \n      maxActions = 10, \n      priorityThreshold = 'medium' \n    } = options;\n    \n    this.logger.info(`üéØ Creating action plan for ${businessId} (${timeHorizon})`);\n    \n    try {\n      // Verificar cache\n      const cacheKey = `${businessId}_${timeHorizon}_${JSON.stringify(options)}`;\n      const cached = this.planCache.get(cacheKey);\n      \n      if (cached && Date.now() - cached.timestamp.getTime() < this.cacheTimeout) {\n        this.logger.debug('üîÑ Using cached action plan');\n        return cached.plan;\n      }\n      \n      // 1. Generar acciones candidatas de diferentes fuentes\n      const candidateActions = await this.generateCandidateActions(\n        analysis, \n        timeHorizon, \n        businessId\n      );\n      \n      // 2. Priorizar acciones usando m√∫ltiples criterios\n      const prioritizedActions = await this.prioritizeActions(\n        candidateActions, \n        analysis, \n        options\n      );\n      \n      // 3. Optimizar secuencia y dependencias\n      const optimizedSequence = await this.optimizeActionSequence(\n        prioritizedActions, \n        timeHorizon\n      );\n      \n      // 4. Validar recursos y restricciones\n      const feasibleActions = await this.validateResourceConstraints(\n        optimizedSequence, \n        options\n      );\n      \n      // 5. Crear plan final\n      const plan = await this.buildFinalPlan(\n        feasibleActions, \n        analysis, \n        options\n      );\n      \n      // Guardar en cache\n      this.planCache.set(cacheKey, {\n        plan,\n        timestamp: new Date()\n      });\n      \n      // Almacenar plan en memoria para aprendizaje futuro\n      await this.storePlanForLearning(plan, analysis, options);\n      \n      this.logger.info(\n        `‚úÖ Action plan created with ${plan.actions.length} actions (confidence: ${plan.confidence})`\n      );\n      \n      return plan;\n      \n    } catch (error) {\n      this.logger.error('‚ùå Failed to create action plan:', error);\n      throw error;\n    }\n  }\n  \n  // ==========================================================================\n  // GENERACI√ìN DE ACCIONES CANDIDATAS\n  // ==========================================================================\n  \n  private async generateCandidateActions(\n    analysis: BusinessAnalysis,\n    timeHorizon: string,\n    businessId?: string\n  ): Promise<Action[]> {\n    const candidateActions: Action[] = [];\n    \n    // 1. Acciones basadas en oportunidades identificadas\n    const opportunityActions = await this.generateOpportunityActions(analysis.opportunities);\n    candidateActions.push(...opportunityActions);\n    \n    // 2. Acciones para mitigar riesgos\n    const riskMitigationActions = await this.generateRiskMitigationActions(analysis.risks);\n    candidateActions.push(...riskMitigationActions);\n    \n    // 3. Acciones basadas en m√©tricas de performance\n    const performanceActions = await this.generatePerformanceActions(analysis.metrics);\n    candidateActions.push(...performanceActions);\n    \n    // 4. Acciones competitivas\n    const competitiveActions = await this.generateCompetitiveActions(analysis.competitive);\n    candidateActions.push(...competitiveActions);\n    \n    // 5. Acciones proactivas basadas en patrones hist√≥ricos\n    const proactiveActions = await this.generateProactiveActions(businessId, timeHorizon);\n    candidateActions.push(...proactiveActions);\n    \n    // 6. Acciones de rutina y mantenimiento\n    const routineActions = await this.generateRoutineActions(timeHorizon, businessId);\n    candidateActions.push(...routineActions);\n    \n    return candidateActions;\n  }\n  \n  private async generateOpportunityActions(opportunities: Opportunity[]): Promise<Action[]> {\n    const actions: Action[] = [];\n    \n    for (const opportunity of opportunities) {\n      switch (opportunity.type) {\n        case 'content_creation':\n          actions.push(await this.createContentAction(opportunity));\n          break;\n          \n        case 'promotion':\n          actions.push(await this.createPromotionAction(opportunity));\n          break;\n          \n        case 'customer_retention':\n          actions.push(await this.createRetentionAction(opportunity));\n          break;\n          \n        case 'new_audience':\n          actions.push(await this.createAudienceExpansionAction(opportunity));\n          break;\n          \n        case 'competitor_response':\n          actions.push(await this.createCompetitiveResponseAction(opportunity));\n          break;\n          \n        case 'trend_capitalization':\n          actions.push(await this.createTrendAction(opportunity));\n          break;\n          \n        case 'upsell_crosssell':\n          actions.push(await this.createUpsellAction(opportunity));\n          break;\n      }\n    }\n    \n    return actions.filter(action => action !== null);\n  }\n  \n  private async generateRiskMitigationActions(risks: Risk[]): Promise<Action[]> {\n    const actions: Action[] = [];\n    \n    for (const risk of risks) {\n      // Usar acciones de mitigaci√≥n ya definidas en el riesgo\n      if (risk.mitigation && risk.mitigation.length > 0) {\n        actions.push(...risk.mitigation);\n      } else {\n        // Generar acciones de mitigaci√≥n autom√°ticas\n        const mitigationActions = await this.generateAutomaticMitigation(risk);\n        actions.push(...mitigationActions);\n      }\n    }\n    \n    return actions;\n  }\n  \n  private async generatePerformanceActions(metrics: any): Promise<Action[]> {\n    const actions: Action[] = [];\n    \n    // Acciones basadas en tendencia de ventas\n    if (metrics.salesTrend?.direction === 'down') {\n      actions.push({\n        id: `sales_recovery_${Date.now()}`,\n        type: 'create_promotion',\n        title: 'Promoci√≥n de recuperaci√≥n de ventas',\n        description: 'Crear promoci√≥n para revertir tendencia negativa de ventas',\n        parameters: {\n          type: 'recovery',\n          urgency: 'high',\n          discount: Math.min(metrics.salesTrend.percentage * 1.5, 30)\n        },\n        priority: 'high',\n        estimatedDuration: 30,\n        status: 'pending'\n      });\n    }\n    \n    // Acciones basadas en engagement\n    if (metrics.engagementRate < 0.02) { // Menos del 2%\n      actions.push({\n        id: `engagement_boost_${Date.now()}`,\n        type: 'create_content',\n        title: 'Contenido para mejorar engagement',\n        description: 'Crear contenido interactivo para aumentar engagement',\n        parameters: {\n          contentType: 'interactive',\n          platform: 'instagram',\n          objective: 'engagement'\n        },\n        priority: 'medium',\n        estimatedDuration: 45,\n        status: 'pending'\n      });\n    }\n    \n    // Acciones basadas en conversi√≥n\n    if (metrics.conversionFunnel?.purchase < 0.02) { // Menos del 2% de conversi√≥n\n      actions.push({\n        id: `conversion_optimize_${Date.now()}`,\n        type: 'optimize_funnel',\n        title: 'Optimizar funnel de conversi√≥n',\n        description: 'Mejorar proceso de compra para aumentar conversiones',\n        parameters: {\n          focus: 'purchase_flow',\n          priority: 'high'\n        },\n        priority: 'high',\n        estimatedDuration: 60,\n        status: 'pending'\n      });\n    }\n    \n    return actions;\n  }\n  \n  // ==========================================================================\n  // PRIORIZACI√ìN INTELIGENTE\n  // ==========================================================================\n  \n  private async prioritizeActions(\n    candidateActions: Action[], \n    analysis: BusinessAnalysis, \n    options: PlanningOptions\n  ): Promise<Action[]> {\n    this.logger.info(`üéØ Prioritizing ${candidateActions.length} candidate actions`);\n    \n    // Calcular score de prioridad para cada acci√≥n\n    const scoredActions = await Promise.all(\n      candidateActions.map(async (action) => {\n        const score = await this.calculateActionScore(action, analysis, options);\n        return { action, score };\n      })\n    );\n    \n    // Ordenar por score descendente\n    scoredActions.sort((a, b) => b.score - a.score);\n    \n    // Filtrar por umbral de prioridad\n    const threshold = this.getPriorityThreshold(options.priorityThreshold || 'medium');\n    const filteredActions = scoredActions.filter(item => item.score >= threshold);\n    \n    // Limitar cantidad seg√∫n opciones\n    const limitedActions = filteredActions\n      .slice(0, options.maxActions || 10)\n      .map(item => item.action);\n    \n    this.logger.info(\n      `‚úÖ ${limitedActions.length} actions prioritized (threshold: ${threshold})`\n    );\n    \n    return limitedActions;\n  }\n  \n  private async calculateActionScore(\n    action: Action, \n    analysis: BusinessAnalysis, \n    options: PlanningOptions\n  ): Promise<number> {\n    let score = 0;\n    \n    // 1. Score base por prioridad de la acci√≥n\n    score += this.getBasePriorityScore(action.priority);\n    \n    // 2. Score por impacto estimado\n    score += await this.calculateImpactScore(action, analysis);\n    \n    // 3. Score por urgencia (deadline)\n    score += this.calculateUrgencyScore(action);\n    \n    // 4. Score por facilidad de ejecuci√≥n\n    score += await this.calculateFeasibilityScore(action);\n    \n    // 5. Score por alineaci√≥n estrat√©gica\n    score += await this.calculateAlignmentScore(action, analysis);\n    \n    // 6. Score por hist√≥rico de efectividad\n    score += await this.calculateHistoricalScore(action);\n    \n    // 7. Penalizaciones por recursos limitados\n    score -= await this.calculateResourcePenalty(action);\n    \n    return Math.max(0, score);\n  }\n  \n  private getBasePriorityScore(priority: string): number {\n    const scores = {\n      'critical': 100,\n      'high': 80,\n      'medium': 50,\n      'low': 30,\n      'background': 10\n    };\n    return scores[priority as keyof typeof scores] || 50;\n  }\n  \n  private async calculateImpactScore(action: Action, analysis: BusinessAnalysis): Promise<number> {\n    // Estimar impacto basado en tipo de acci√≥n y contexto del negocio\n    let impactScore = 0;\n    \n    switch (action.type) {\n      case 'create_promotion':\n        // Mayor impacto si las ventas est√°n bajas\n        if (analysis.metrics.salesTrend?.direction === 'down') {\n          impactScore += 40;\n        } else {\n          impactScore += 20;\n        }\n        break;\n        \n      case 'create_content':\n        // Mayor impacto si el engagement est√° bajo\n        if (analysis.metrics.engagementRate < 0.02) {\n          impactScore += 35;\n        } else {\n          impactScore += 15;\n        }\n        break;\n        \n      case 'send_message':\n        // Siempre alto impacto para comunicaci√≥n con clientes\n        impactScore += 45;\n        break;\n        \n      case 'analyze_competitor':\n        // Impacto medio, importante para estrategia\n        impactScore += 25;\n        break;\n        \n      default:\n        impactScore += 20;\n    }\n    \n    return impactScore;\n  }\n  \n  private calculateUrgencyScore(action: Action): number {\n    if (!action.deadline) return 0;\n    \n    const now = Date.now();\n    const deadline = action.deadline.getTime();\n    const timeLeft = deadline - now;\n    \n    // M√°s urgente = mayor score\n    if (timeLeft < 60 * 60 * 1000) { // Menos de 1 hora\n      return 30;\n    } else if (timeLeft < 24 * 60 * 60 * 1000) { // Menos de 24 horas\n      return 20;\n    } else if (timeLeft < 7 * 24 * 60 * 60 * 1000) { // Menos de 1 semana\n      return 10;\n    }\n    \n    return 0;\n  }\n  \n  // ==========================================================================\n  // OPTIMIZACI√ìN DE SECUENCIA\n  // ==========================================================================\n  \n  private async optimizeActionSequence(\n    actions: Action[], \n    timeHorizon: string\n  ): Promise<Action[]> {\n    this.logger.info(`üîÑ Optimizing sequence of ${actions.length} actions`);\n    \n    // 1. Agrupar acciones por dependencias\n    const dependencyGroups = this.groupByDependencies(actions);\n    \n    // 2. Ordenar dentro de cada grupo por prioridad y timing\n    const optimizedGroups = dependencyGroups.map(group => \n      this.optimizeGroupSequence(group, timeHorizon)\n    );\n    \n    // 3. Combinar grupos respetando dependencias\n    const optimizedSequence = this.combineGroups(optimizedGroups);\n    \n    // 4. Ajustar timing para evitar sobrecarga\n    const balancedSequence = await this.balanceWorkload(optimizedSequence, timeHorizon);\n    \n    this.logger.info(`‚úÖ Action sequence optimized`);\n    return balancedSequence;\n  }\n  \n  private groupByDependencies(actions: Action[]): Action[][] {\n    const groups: Action[][] = [];\n    const processed = new Set<string>();\n    \n    for (const action of actions) {\n      if (processed.has(action.id)) continue;\n      \n      const group = [action];\n      processed.add(action.id);\n      \n      // Encontrar acciones dependientes\n      const findDependents = (actionId: string) => {\n        for (const otherAction of actions) {\n          if (!processed.has(otherAction.id) && \n              otherAction.dependencies?.includes(actionId)) {\n            group.push(otherAction);\n            processed.add(otherAction.id);\n            findDependents(otherAction.id); // Recursivo\n          }\n        }\n      };\n      \n      findDependents(action.id);\n      groups.push(group);\n    }\n    \n    return groups;\n  }\n  \n  // ==========================================================================\n  // VALIDACI√ìN Y CONSTRUCCI√ìN DEL PLAN\n  // ==========================================================================\n  \n  private async buildFinalPlan(\n    actions: Action[], \n    analysis: BusinessAnalysis, \n    options: PlanningOptions\n  ): Promise<ActionPlan> {\n    // Calcular m√©tricas del plan\n    const totalDuration = actions.reduce((sum, action) => sum + action.estimatedDuration, 0);\n    const avgPriority = this.calculateAveragePriority(actions);\n    const confidence = await this.calculatePlanConfidence(actions, analysis);\n    \n    // Generar rationale del plan\n    const rationale = await this.generatePlanRationale(actions, analysis, options);\n    \n    // Establecer timeframe\n    const timeframe = this.calculateTimeframe(actions, options.timeHorizon || 'immediate');\n    \n    const plan: ActionPlan = {\n      id: `plan_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,\n      actions,\n      rationale,\n      confidence,\n      timeframe,\n      createdAt: new Date(),\n      businessId: options.businessId,\n      totalDuration,\n      avgPriority,\n      metadata: {\n        analysisVersion: analysis.metrics?.timestamp || new Date().toISOString(),\n        planningEngine: 'orbit-v1',\n        options: options\n      }\n    };\n    \n    return plan;\n  }\n  \n  private async calculatePlanConfidence(\n    actions: Action[], \n    analysis: BusinessAnalysis\n  ): Promise<number> {\n    let confidence = 0.7; // Base confidence\n    \n    // Aumentar confianza si hay m√°s datos de an√°lisis\n    if (analysis.opportunities.length > 0) confidence += 0.1;\n    if (analysis.competitive) confidence += 0.05;\n    if (analysis.sentiment?.overall > 0.5) confidence += 0.05;\n    \n    // Reducir confianza si hay muchos riesgos\n    const highRisks = analysis.risks.filter(r => r.severity === 'high' || r.severity === 'critical');\n    confidence -= highRisks.length * 0.05;\n    \n    // Ajustar por experiencia hist√≥rica con tipos de acciones similares\n    for (const action of actions) {\n      const historicalSuccess = await this.getHistoricalSuccessRate(action.type);\n      confidence += (historicalSuccess - 0.5) * 0.1; // Ajuste basado en √©xito hist√≥rico\n    }\n    \n    return Math.max(0.3, Math.min(0.95, confidence));\n  }\n  \n  // ==========================================================================\n  // M√âTODOS AUXILIARES PRIVADOS\n  // ==========================================================================\n  \n  private initializeIndustryStrategies(): void {\n    // Estrategias espec√≠ficas por industria\n    this.industryStrategies.set('food', {\n      priorityWeights: { promotion: 1.2, content: 1.1, timing: 1.3 },\n      preferredActions: ['create_promotion', 'send_message', 'create_content'],\n      timing: { peakHours: [11, 12, 13, 19, 20], offDays: [] }\n    });\n    \n    this.industryStrategies.set('retail', {\n      priorityWeights: { promotion: 1.3, content: 1.2, timing: 1.0 },\n      preferredActions: ['create_content', 'create_promotion', 'analyze_competitor'],\n      timing: { peakHours: [18, 19, 20, 21], offDays: [1] } // Lunes suele ser m√°s bajo\n    });\n    \n    this.industryStrategies.set('services', {\n      priorityWeights: { content: 1.3, communication: 1.2, analysis: 1.1 },\n      preferredActions: ['send_message', 'create_content', 'generate_report'],\n      timing: { peakHours: [9, 10, 11, 14, 15], offDays: [0, 6] } // Weekends\n    });\n  }\n  \n  private getPriorityThreshold(threshold: string): number {\n    const thresholds = {\n      'low': 20,\n      'medium': 50,\n      'high': 80,\n      'critical': 100\n    };\n    return thresholds[threshold as keyof typeof thresholds] || 50;\n  }\n  \n  private calculateAveragePriority(actions: Action[]): number {\n    const priorityValues = {\n      'critical': 5,\n      'high': 4,\n      'medium': 3,\n      'low': 2,\n      'background': 1\n    };\n    \n    const total = actions.reduce((sum, action) => {\n      return sum + (priorityValues[action.priority as keyof typeof priorityValues] || 3);\n    }, 0);\n    \n    return actions.length > 0 ? total / actions.length : 3;\n  }\n  \n  private calculateTimeframe(actions: Action[], horizon: string): string {\n    const maxDuration = Math.max(...actions.map(a => a.estimatedDuration));\n    const totalDuration = actions.reduce((sum, a) => sum + a.estimatedDuration, 0);\n    \n    if (horizon === 'immediate' || totalDuration < 120) {\n      return '2 horas';\n    } else if (horizon === 'short_term' || totalDuration < 480) {\n      return '1 d√≠a';\n    } else if (horizon === 'medium_term') {\n      return '1 semana';\n    } else {\n      return '1 mes';\n    }\n  }\n  \n  private async generatePlanRationale(\n    actions: Action[], \n    analysis: BusinessAnalysis, \n    options: PlanningOptions\n  ): Promise<string> {\n    const reasons = [];\n    \n    if (analysis.opportunities.length > 0) {\n      reasons.push(`Identificadas ${analysis.opportunities.length} oportunidades clave`);\n    }\n    \n    if (analysis.risks.some(r => r.severity === 'high' || r.severity === 'critical')) {\n      reasons.push('Mitigaci√≥n de riesgos cr√≠ticos identificados');\n    }\n    \n    if (analysis.metrics.salesTrend?.direction === 'down') {\n      reasons.push('Recuperaci√≥n de tendencia negativa en ventas');\n    }\n    \n    if (actions.some(a => a.type === 'create_content')) {\n      reasons.push('Fortalecimiento de presencia digital');\n    }\n    \n    return reasons.length > 0 \n      ? reasons.join(', ') + '.'\n      : 'Plan optimizado para mejora general del rendimiento.';\n  }\n  \n  // M√©todos placeholder para completar la implementaci√≥n\n  private async createContentAction(opportunity: Opportunity): Promise<Action> {\n    return {\n      id: `content_${Date.now()}`,\n      type: 'create_content',\n      title: opportunity.title,\n      description: opportunity.description,\n      parameters: { opportunityId: opportunity.id },\n      priority: opportunity.priority,\n      estimatedDuration: 45,\n      status: 'pending'\n    };\n  }\n  \n  private async createPromotionAction(opportunity: Opportunity): Promise<Action> {\n    return {\n      id: `promo_${Date.now()}`,\n      type: 'create_promotion',\n      title: opportunity.title,\n      description: opportunity.description,\n      parameters: { \n        opportunityId: opportunity.id,\n        urgency: opportunity.priority === 'critical' ? 'high' : 'medium'\n      },\n      priority: opportunity.priority,\n      estimatedDuration: 30,\n      status: 'pending'\n    };\n  }\n  \n  // Otros m√©todos placeholder...\n  private async createRetentionAction(opportunity: Opportunity): Promise<Action> { return this.createContentAction(opportunity); }\n  private async createAudienceExpansionAction(opportunity: Opportunity): Promise<Action> { return this.createContentAction(opportunity); }\n  private async createCompetitiveResponseAction(opportunity: Opportunity): Promise<Action> { return this.createContentAction(opportunity); }\n  private async createTrendAction(opportunity: Opportunity): Promise<Action> { return this.createContentAction(opportunity); }\n  private async createUpsellAction(opportunity: Opportunity): Promise<Action> { return this.createContentAction(opportunity); }\n  private async generateAutomaticMitigation(risk: Risk): Promise<Action[]> { return []; }\n  private async generateCompetitiveActions(competitive: any): Promise<Action[]> { return []; }\n  private async generateProactiveActions(businessId?: string, timeHorizon?: string): Promise<Action[]> { return []; }\n  private async generateRoutineActions(timeHorizon: string, businessId?: string): Promise<Action[]> { return []; }\n  private async calculateFeasibilityScore(action: Action): Promise<number> { return 20; }\n  private async calculateAlignmentScore(action: Action, analysis: BusinessAnalysis): Promise<number> { return 15; }\n  private async calculateHistoricalScore(action: Action): Promise<number> { return 10; }\n  private async calculateResourcePenalty(action: Action): Promise<number> { return 5; }\n  private optimizeGroupSequence(group: Action[], timeHorizon: string): Action[] { return group; }\n  private combineGroups(groups: Action[][]): Action[] { return groups.flat(); }\n  private async balanceWorkload(actions: Action[], timeHorizon: string): Promise<Action[]> { return actions; }\n  private async validateResourceConstraints(actions: Action[], options: PlanningOptions): Promise<Action[]> { return actions; }\n  private async getHistoricalSuccessRate(actionType: string): Promise<number> { return 0.7; }\n  private async storePlanForLearning(plan: ActionPlan, analysis: BusinessAnalysis, options: PlanningOptions): Promise<void> {\n    await this.memory.store(\n      `Action plan created: ${plan.actions.length} actions with ${plan.confidence} confidence`,\n      {\n        type: 'plan',\n        planId: plan.id,\n        businessId: options.businessId,\n        timestamp: new Date().toISOString()\n      }\n    );\n  }\n}\n\n// =============================================================================\n// INTERFACES DE SOPORTE\n// =============================================================================\n\ninterface PlanningOptions {\n  businessId?: string;\n  timeHorizon?: 'immediate' | 'short_term' | 'medium_term' | 'long_term';\n  maxActions?: number;\n  priorityThreshold?: 'low' | 'medium' | 'high' | 'critical';\n  constraints?: {\n    maxBudget?: number;\n    maxDuration?: number;\n    requiredApproval?: boolean;\n  };\n}\n\ninterface ActionPlan {\n  id: string;\n  actions: Action[];\n  rationale: string;\n  confidence: number;\n  timeframe: string;\n  createdAt: Date;\n  businessId?: string;\n  totalDuration: number;\n  avgPriority: number;\n  metadata?: {\n    analysisVersion: string;\n    planningEngine: string;\n    options: PlanningOptions;\n  };\n}\n\ninterface PlanningStrategy {\n  priorityWeights: Record<string, number>;\n  preferredActions: string[];\n  timing: {\n    peakHours: number[];\n    offDays: number[];\n  };\n}"